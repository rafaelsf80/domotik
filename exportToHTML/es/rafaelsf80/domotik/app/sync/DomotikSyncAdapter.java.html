<html>
<head>
<title>DomotikSyncAdapter.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: rgb(0,0,0); font-weight: normal; font-style: normal; }
.s0 { color: rgb(204,120,50); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(128,128,128); }
.s3 { color: rgb(104,151,187); }
.s4 { color: rgb(106,135,89); }
.s5 { color: rgb(98,151,85); font-style: italic; }
.s6 { color: rgb(98,151,85); font-weight: bold; font-style: italic; }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#C0C0C0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
DomotikSyncAdapter.java</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">package </span><span class="s1">es.rafaelsf80.domotik.app.sync</span><span class="s0">;</span><span class="s1"> 
 
</span><span class="s0">import </span><span class="s1">android.accounts.Account</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.accounts.AccountManager</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.app.NotificationManager</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.app.PendingIntent</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.content.AbstractThreadedSyncAdapter</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.content.ContentProviderClient</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.content.ContentResolver</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.content.ContentUris</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.content.ContentValues</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.content.Context</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.content.Intent</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.content.SharedPreferences</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.content.SyncRequest</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.content.SyncResult</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.content.res.Resources</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.database.Cursor</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.graphics.Bitmap</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.graphics.BitmapFactory</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.net.Uri</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.os.Build</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.os.Bundle</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.preference.PreferenceManager</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.support.v4.app.NotificationCompat</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.support.v4.app.TaskStackBuilder</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.text.format.Time</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">android.util.Log</span><span class="s0">;</span><span class="s1"> 
 
</span><span class="s0">import </span><span class="s1">org.json.JSONArray</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">org.json.JSONException</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">org.json.JSONObject</span><span class="s0">;</span><span class="s1"> 
 
</span><span class="s0">import </span><span class="s1">java.io.BufferedReader</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">java.io.IOException</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">java.io.InputStream</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">java.io.InputStreamReader</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">java.net.HttpURLConnection</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">java.net.URL</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">java.util.Vector</span><span class="s0">;</span><span class="s1"> 
 
</span><span class="s0">import </span><span class="s1">es.rafaelsf80.domotik.R</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">es.rafaelsf80.domotik.app.Main</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">es.rafaelsf80.domotik.app.Utility</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">es.rafaelsf80.domotik.app.weather.WeatherContract</span><span class="s0">;</span><span class="s1"> 
 
</span><span class="s0">public class </span><span class="s1">DomotikSyncAdapter </span><span class="s0">extends </span><span class="s1">AbstractThreadedSyncAdapter { 
    </span><span class="s0">public final </span><span class="s1">String LOG_TAG = DomotikSyncAdapter.</span><span class="s0">class</span><span class="s1">.getSimpleName()</span><span class="s0">;</span><span class="s1"> 
    </span><span class="s2">// Interval at which to sync with the weather, in seconds.</span><span class="s1"> 
    </span><span class="s2">// 60 seconds (1 minute) * 180 = 3 hours</span><span class="s1"> 
    </span><span class="s0">public static final int </span><span class="s1">SYNC_INTERVAL = </span><span class="s3">60 </span><span class="s1">* </span><span class="s3">180</span><span class="s0">;</span><span class="s1"> 
    </span><span class="s0">public static final int </span><span class="s1">SYNC_FLEXTIME = SYNC_INTERVAL/</span><span class="s3">3</span><span class="s0">;</span><span class="s1"> 
    </span><span class="s0">private static final long </span><span class="s1">DAY_IN_MILLIS = </span><span class="s3">1000 </span><span class="s1">* </span><span class="s3">60 </span><span class="s1">* </span><span class="s3">60 </span><span class="s1">* </span><span class="s3">24</span><span class="s0">;</span><span class="s1"> 
    </span><span class="s0">private static final int </span><span class="s1">WEATHER_NOTIFICATION_ID = </span><span class="s3">3004</span><span class="s0">;</span><span class="s1"> 
 
 
    </span><span class="s0">private static final </span><span class="s1">String[] NOTIFY_WEATHER_PROJECTION = </span><span class="s0">new </span><span class="s1">String[] { 
            WeatherContract.WeatherEntry.COLUMN_WEATHER_ID</span><span class="s0">,</span><span class="s1"> 
            WeatherContract.WeatherEntry.COLUMN_MAX_TEMP</span><span class="s0">,</span><span class="s1"> 
            WeatherContract.WeatherEntry.COLUMN_MIN_TEMP</span><span class="s0">,</span><span class="s1"> 
            WeatherContract.WeatherEntry.COLUMN_SHORT_DESC 
    }</span><span class="s0">;</span><span class="s1"> 
 
    </span><span class="s2">// these indices must match the projection</span><span class="s1"> 
    </span><span class="s0">private static final int </span><span class="s1">INDEX_WEATHER_ID = </span><span class="s3">0</span><span class="s0">;</span><span class="s1"> 
    </span><span class="s0">private static final int </span><span class="s1">INDEX_MAX_TEMP = </span><span class="s3">1</span><span class="s0">;</span><span class="s1"> 
    </span><span class="s0">private static final int </span><span class="s1">INDEX_MIN_TEMP = </span><span class="s3">2</span><span class="s0">;</span><span class="s1"> 
    </span><span class="s0">private static final int </span><span class="s1">INDEX_SHORT_DESC = </span><span class="s3">3</span><span class="s0">;</span><span class="s1"> 
 
    </span><span class="s0">public </span><span class="s1">DomotikSyncAdapter(Context context</span><span class="s0">, boolean </span><span class="s1">autoInitialize) { 
        </span><span class="s0">super</span><span class="s1">(context</span><span class="s0">, </span><span class="s1">autoInitialize)</span><span class="s0">;</span><span class="s1"> 
    } 
 
    @Override 
    </span><span class="s0">public void </span><span class="s1">onPerformSync(Account account</span><span class="s0">, </span><span class="s1">Bundle extras</span><span class="s0">, </span><span class="s1">String authority</span><span class="s0">, </span><span class="s1">ContentProviderClient provider</span><span class="s0">, </span><span class="s1">SyncResult syncResult) { 
        Log.d(LOG_TAG</span><span class="s0">, </span><span class="s4">&quot;Starting sync&quot;</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
        String locationQuery = Utility.getPreferredLocation(getContext())</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s2">// These two need to be declared outside the try/catch</span><span class="s1"> 
        </span><span class="s2">// so that they can be closed in the finally block.</span><span class="s1"> 
        HttpURLConnection urlConnection = </span><span class="s0">null;</span><span class="s1"> 
        BufferedReader reader = </span><span class="s0">null;</span><span class="s1"> 
 
        </span><span class="s2">// Will contain the raw JSON response as a string.</span><span class="s1"> 
        String forecastJsonStr = </span><span class="s0">null;</span><span class="s1"> 
 
        String format = </span><span class="s4">&quot;json&quot;</span><span class="s0">;</span><span class="s1"> 
        String units = </span><span class="s4">&quot;metric&quot;</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">int </span><span class="s1">numDays = </span><span class="s3">14</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s0">try </span><span class="s1">{ 
            </span><span class="s2">// Construct the URL for the OpenWeatherMap query</span><span class="s1"> 
            </span><span class="s2">// Possible parameters are avaiable at OWM's forecast API page, at</span><span class="s1"> 
            </span><span class="s2">// http://openweathermap.org/API#forecast</span><span class="s1"> 
            </span><span class="s0">final </span><span class="s1">String FORECAST_BASE_URL = 
                    </span><span class="s4">&quot;http://api.openweathermap.org/data/2.5/forecast/daily?&quot;</span><span class="s0">;</span><span class="s1"> 
            </span><span class="s0">final </span><span class="s1">String QUERY_PARAM = </span><span class="s4">&quot;q&quot;</span><span class="s0">;</span><span class="s1"> 
            </span><span class="s0">final </span><span class="s1">String FORMAT_PARAM = </span><span class="s4">&quot;mode&quot;</span><span class="s0">;</span><span class="s1"> 
            </span><span class="s0">final </span><span class="s1">String UNITS_PARAM = </span><span class="s4">&quot;units&quot;</span><span class="s0">;</span><span class="s1"> 
            </span><span class="s0">final </span><span class="s1">String DAYS_PARAM = </span><span class="s4">&quot;cnt&quot;</span><span class="s0">;</span><span class="s1"> 
            </span><span class="s0">final </span><span class="s1">String APPID_PARAM = </span><span class="s4">&quot;APPID&quot;</span><span class="s0">;</span><span class="s1"> 
 
            Uri builtUri = Uri.parse(FORECAST_BASE_URL).buildUpon() 
                    .appendQueryParameter(QUERY_PARAM</span><span class="s0">, </span><span class="s1">locationQuery) 
                    .appendQueryParameter(FORMAT_PARAM</span><span class="s0">, </span><span class="s1">format) 
                    .appendQueryParameter(UNITS_PARAM</span><span class="s0">, </span><span class="s1">units) 
                    .appendQueryParameter(DAYS_PARAM</span><span class="s0">, </span><span class="s1">Integer.toString(numDays)) 
                    .appendQueryParameter(APPID_PARAM</span><span class="s0">, </span><span class="s1">Main.OPEN_WEATHER_MAP_API_KEY) 
                    .build()</span><span class="s0">;</span><span class="s1"> 
 
            URL url = </span><span class="s0">new </span><span class="s1">URL(builtUri.toString())</span><span class="s0">;</span><span class="s1"> 
 
            </span><span class="s2">// Create the request to OpenWeatherMap, and open the connection</span><span class="s1"> 
            urlConnection = (HttpURLConnection) url.openConnection()</span><span class="s0">;</span><span class="s1"> 
            urlConnection.setRequestMethod(</span><span class="s4">&quot;GET&quot;</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
            urlConnection.connect()</span><span class="s0">;</span><span class="s1"> 
 
            </span><span class="s2">// Read the input stream into a String</span><span class="s1"> 
            InputStream inputStream = urlConnection.getInputStream()</span><span class="s0">;</span><span class="s1"> 
            StringBuffer buffer = </span><span class="s0">new </span><span class="s1">StringBuffer()</span><span class="s0">;</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">(inputStream == </span><span class="s0">null</span><span class="s1">) { 
                </span><span class="s2">// Nothing to do.</span><span class="s1"> 
                </span><span class="s0">return;</span><span class="s1"> 
            } 
            reader = </span><span class="s0">new </span><span class="s1">BufferedReader(</span><span class="s0">new </span><span class="s1">InputStreamReader(inputStream))</span><span class="s0">;</span><span class="s1"> 
 
            String line</span><span class="s0">;</span><span class="s1"> 
            </span><span class="s0">while </span><span class="s1">((line = reader.readLine()) != </span><span class="s0">null</span><span class="s1">) { 
                </span><span class="s2">// Since it's JSON, adding a newline isn't necessary (it won't affect parsing)</span><span class="s1"> 
                </span><span class="s2">// But it does make debugging a *lot* easier if you print out the completed</span><span class="s1"> 
                </span><span class="s2">// buffer for debugging.</span><span class="s1"> 
                buffer.append(line + </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">if </span><span class="s1">(buffer.length() == </span><span class="s3">0</span><span class="s1">) { 
                </span><span class="s2">// Stream was empty.  No point in parsing.</span><span class="s1"> 
                </span><span class="s0">return;</span><span class="s1"> 
            } 
            forecastJsonStr = buffer.toString()</span><span class="s0">;</span><span class="s1"> 
            getWeatherDataFromJson(forecastJsonStr</span><span class="s0">, </span><span class="s1">locationQuery)</span><span class="s0">;</span><span class="s1"> 
        } </span><span class="s0">catch </span><span class="s1">(IOException e) { 
            Log.e(LOG_TAG</span><span class="s0">, </span><span class="s4">&quot;Error &quot;</span><span class="s0">, </span><span class="s1">e)</span><span class="s0">;</span><span class="s1"> 
            </span><span class="s2">// If the code didn't successfully get the weather data, there's no point in attempting</span><span class="s1"> 
            </span><span class="s2">// to parse it.</span><span class="s1"> 
        } </span><span class="s0">catch </span><span class="s1">(JSONException e) { 
            Log.e(LOG_TAG</span><span class="s0">, </span><span class="s1">e.getMessage()</span><span class="s0">, </span><span class="s1">e)</span><span class="s0">;</span><span class="s1"> 
            e.printStackTrace()</span><span class="s0">;</span><span class="s1"> 
        } </span><span class="s0">finally </span><span class="s1">{ 
            </span><span class="s0">if </span><span class="s1">(urlConnection != </span><span class="s0">null</span><span class="s1">) { 
                urlConnection.disconnect()</span><span class="s0">;</span><span class="s1"> 
            } 
            </span><span class="s0">if </span><span class="s1">(reader != </span><span class="s0">null</span><span class="s1">) { 
                </span><span class="s0">try </span><span class="s1">{ 
                    reader.close()</span><span class="s0">;</span><span class="s1"> 
                } </span><span class="s0">catch </span><span class="s1">(</span><span class="s0">final </span><span class="s1">IOException e) { 
                    Log.e(LOG_TAG</span><span class="s0">, </span><span class="s4">&quot;Error closing stream&quot;</span><span class="s0">, </span><span class="s1">e)</span><span class="s0">;</span><span class="s1"> 
                } 
            } 
        } 
        </span><span class="s0">return;</span><span class="s1"> 
    } 
 
    </span><span class="s5">/** 
     * Take the String representing the complete forecast in JSON Format and 
     * pull out the data we need to construct the Strings needed for the wireframes. 
     * 
     * Fortunately parsing is easy:  constructor takes the JSON string and converts it 
     * into an Object hierarchy for us. 
     */</span><span class="s1"> 
    </span><span class="s0">private void </span><span class="s1">getWeatherDataFromJson(String forecastJsonStr</span><span class="s0">,</span><span class="s1"> 
                                        String locationSetting) 
            </span><span class="s0">throws </span><span class="s1">JSONException { 
 
        </span><span class="s2">// Now we have a String representing the complete forecast in JSON Format.</span><span class="s1"> 
        </span><span class="s2">// Fortunately parsing is easy:  constructor takes the JSON string and converts it</span><span class="s1"> 
        </span><span class="s2">// into an Object hierarchy for us.</span><span class="s1"> 
 
        </span><span class="s2">// These are the names of the JSON objects that need to be extracted.</span><span class="s1"> 
 
        </span><span class="s2">// Location information</span><span class="s1"> 
        </span><span class="s0">final </span><span class="s1">String OWM_CITY = </span><span class="s4">&quot;city&quot;</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">final </span><span class="s1">String OWM_CITY_NAME = </span><span class="s4">&quot;name&quot;</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">final </span><span class="s1">String OWM_COORD = </span><span class="s4">&quot;coord&quot;</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s2">// Location coordinate</span><span class="s1"> 
        </span><span class="s0">final </span><span class="s1">String OWM_LATITUDE = </span><span class="s4">&quot;lat&quot;</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">final </span><span class="s1">String OWM_LONGITUDE = </span><span class="s4">&quot;lon&quot;</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s2">// Weather information.  Each day's forecast info is an element of the &quot;list&quot; array.</span><span class="s1"> 
        </span><span class="s0">final </span><span class="s1">String OWM_LIST = </span><span class="s4">&quot;list&quot;</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s0">final </span><span class="s1">String OWM_PRESSURE = </span><span class="s4">&quot;pressure&quot;</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">final </span><span class="s1">String OWM_HUMIDITY = </span><span class="s4">&quot;humidity&quot;</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">final </span><span class="s1">String OWM_WINDSPEED = </span><span class="s4">&quot;speed&quot;</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">final </span><span class="s1">String OWM_WIND_DIRECTION = </span><span class="s4">&quot;deg&quot;</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s2">// All temperatures are children of the &quot;temp&quot; object.</span><span class="s1"> 
        </span><span class="s0">final </span><span class="s1">String OWM_TEMPERATURE = </span><span class="s4">&quot;temp&quot;</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">final </span><span class="s1">String OWM_MAX = </span><span class="s4">&quot;max&quot;</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">final </span><span class="s1">String OWM_MIN = </span><span class="s4">&quot;min&quot;</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s0">final </span><span class="s1">String OWM_WEATHER = </span><span class="s4">&quot;weather&quot;</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">final </span><span class="s1">String OWM_DESCRIPTION = </span><span class="s4">&quot;main&quot;</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">final </span><span class="s1">String OWM_WEATHER_ID = </span><span class="s4">&quot;id&quot;</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s0">try </span><span class="s1">{ 
            JSONObject forecastJson = </span><span class="s0">new </span><span class="s1">JSONObject(forecastJsonStr)</span><span class="s0">;</span><span class="s1"> 
            JSONArray weatherArray = forecastJson.getJSONArray(OWM_LIST)</span><span class="s0">;</span><span class="s1"> 
 
            JSONObject cityJson = forecastJson.getJSONObject(OWM_CITY)</span><span class="s0">;</span><span class="s1"> 
            String cityName = cityJson.getString(OWM_CITY_NAME)</span><span class="s0">;</span><span class="s1"> 
 
            JSONObject cityCoord = cityJson.getJSONObject(OWM_COORD)</span><span class="s0">;</span><span class="s1"> 
            </span><span class="s0">double </span><span class="s1">cityLatitude = cityCoord.getDouble(OWM_LATITUDE)</span><span class="s0">;</span><span class="s1"> 
            </span><span class="s0">double </span><span class="s1">cityLongitude = cityCoord.getDouble(OWM_LONGITUDE)</span><span class="s0">;</span><span class="s1"> 
 
            </span><span class="s0">long </span><span class="s1">locationId = addLocation(locationSetting</span><span class="s0">, </span><span class="s1">cityName</span><span class="s0">, </span><span class="s1">cityLatitude</span><span class="s0">, </span><span class="s1">cityLongitude)</span><span class="s0">;</span><span class="s1"> 
 
            </span><span class="s2">// Insert the new weather information into the database</span><span class="s1"> 
            Vector&lt;ContentValues&gt; cVVector = </span><span class="s0">new </span><span class="s1">Vector&lt;ContentValues&gt;(weatherArray.length())</span><span class="s0">;</span><span class="s1"> 
 
            </span><span class="s2">// OWM returns daily forecasts based upon the local time of the city that is being</span><span class="s1"> 
            </span><span class="s2">// asked for, which means that we need to know the GMT offset to translate this data</span><span class="s1"> 
            </span><span class="s2">// properly.</span><span class="s1"> 
 
            </span><span class="s2">// Since this data is also sent in-order and the first day is always the</span><span class="s1"> 
            </span><span class="s2">// current day, we're going to take advantage of that to get a nice</span><span class="s1"> 
            </span><span class="s2">// normalized UTC date for all of our weather.</span><span class="s1"> 
 
            Time dayTime = </span><span class="s0">new </span><span class="s1">Time()</span><span class="s0">;</span><span class="s1"> 
            dayTime.setToNow()</span><span class="s0">;</span><span class="s1"> 
 
            </span><span class="s2">// we start at the day returned by local time. Otherwise this is a mess.</span><span class="s1"> 
            </span><span class="s0">int </span><span class="s1">julianStartDay = Time.getJulianDay(System.currentTimeMillis()</span><span class="s0">, </span><span class="s1">dayTime.gmtoff)</span><span class="s0">;</span><span class="s1"> 
 
            </span><span class="s2">// now we work exclusively in UTC</span><span class="s1"> 
            dayTime = </span><span class="s0">new </span><span class="s1">Time()</span><span class="s0">;</span><span class="s1"> 
 
            </span><span class="s0">for</span><span class="s1">(</span><span class="s0">int </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; weatherArray.length()</span><span class="s0">; </span><span class="s1">i++) { 
                </span><span class="s2">// These are the values that will be collected.</span><span class="s1"> 
                </span><span class="s0">long </span><span class="s1">dateTime</span><span class="s0">;</span><span class="s1"> 
                </span><span class="s0">double </span><span class="s1">pressure</span><span class="s0">;</span><span class="s1"> 
                </span><span class="s0">int </span><span class="s1">humidity</span><span class="s0">;</span><span class="s1"> 
                </span><span class="s0">double </span><span class="s1">windSpeed</span><span class="s0">;</span><span class="s1"> 
                </span><span class="s0">double </span><span class="s1">windDirection</span><span class="s0">;</span><span class="s1"> 
 
                </span><span class="s0">double </span><span class="s1">high</span><span class="s0">;</span><span class="s1"> 
                </span><span class="s0">double </span><span class="s1">low</span><span class="s0">;</span><span class="s1"> 
 
                String description</span><span class="s0">;</span><span class="s1"> 
                </span><span class="s0">int </span><span class="s1">weatherId</span><span class="s0">;</span><span class="s1"> 
 
                </span><span class="s2">// Get the JSON object representing the day</span><span class="s1"> 
                JSONObject dayForecast = weatherArray.getJSONObject(i)</span><span class="s0">;</span><span class="s1"> 
 
                </span><span class="s2">// Cheating to convert this to UTC time, which is what we want anyhow</span><span class="s1"> 
                dateTime = dayTime.setJulianDay(julianStartDay+i)</span><span class="s0">;</span><span class="s1"> 
 
                pressure = dayForecast.getDouble(OWM_PRESSURE)</span><span class="s0">;</span><span class="s1"> 
                humidity = dayForecast.getInt(OWM_HUMIDITY)</span><span class="s0">;</span><span class="s1"> 
                windSpeed = dayForecast.getDouble(OWM_WINDSPEED)</span><span class="s0">;</span><span class="s1"> 
                windDirection = dayForecast.getDouble(OWM_WIND_DIRECTION)</span><span class="s0">;</span><span class="s1"> 
 
                </span><span class="s2">// Description is in a child array called &quot;weather&quot;, which is 1 element long.</span><span class="s1"> 
                </span><span class="s2">// That element also contains a weather code.</span><span class="s1"> 
                JSONObject weatherObject = 
                        dayForecast.getJSONArray(OWM_WEATHER).getJSONObject(</span><span class="s3">0</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
                description = weatherObject.getString(OWM_DESCRIPTION)</span><span class="s0">;</span><span class="s1"> 
                weatherId = weatherObject.getInt(OWM_WEATHER_ID)</span><span class="s0">;</span><span class="s1"> 
 
                </span><span class="s2">// Temperatures are in a child object called &quot;temp&quot;.  Try not to name variables</span><span class="s1"> 
                </span><span class="s2">// &quot;temp&quot; when working with temperature.  It confuses everybody.</span><span class="s1"> 
                JSONObject temperatureObject = dayForecast.getJSONObject(OWM_TEMPERATURE)</span><span class="s0">;</span><span class="s1"> 
                high = temperatureObject.getDouble(OWM_MAX)</span><span class="s0">;</span><span class="s1"> 
                low = temperatureObject.getDouble(OWM_MIN)</span><span class="s0">;</span><span class="s1"> 
 
                ContentValues weatherValues = </span><span class="s0">new </span><span class="s1">ContentValues()</span><span class="s0">;</span><span class="s1"> 
 
                weatherValues.put(WeatherContract.WeatherEntry.COLUMN_LOC_KEY</span><span class="s0">, </span><span class="s1">locationId)</span><span class="s0">;</span><span class="s1"> 
                weatherValues.put(WeatherContract.WeatherEntry.COLUMN_DATE</span><span class="s0">, </span><span class="s1">dateTime)</span><span class="s0">;</span><span class="s1"> 
                weatherValues.put(WeatherContract.WeatherEntry.COLUMN_HUMIDITY</span><span class="s0">, </span><span class="s1">humidity)</span><span class="s0">;</span><span class="s1"> 
                weatherValues.put(WeatherContract.WeatherEntry.COLUMN_PRESSURE</span><span class="s0">, </span><span class="s1">pressure)</span><span class="s0">;</span><span class="s1"> 
                weatherValues.put(WeatherContract.WeatherEntry.COLUMN_WIND_SPEED</span><span class="s0">, </span><span class="s1">windSpeed)</span><span class="s0">;</span><span class="s1"> 
                weatherValues.put(WeatherContract.WeatherEntry.COLUMN_DEGREES</span><span class="s0">, </span><span class="s1">windDirection)</span><span class="s0">;</span><span class="s1"> 
                weatherValues.put(WeatherContract.WeatherEntry.COLUMN_MAX_TEMP</span><span class="s0">, </span><span class="s1">high)</span><span class="s0">;</span><span class="s1"> 
                weatherValues.put(WeatherContract.WeatherEntry.COLUMN_MIN_TEMP</span><span class="s0">, </span><span class="s1">low)</span><span class="s0">;</span><span class="s1"> 
                weatherValues.put(WeatherContract.WeatherEntry.COLUMN_SHORT_DESC</span><span class="s0">, </span><span class="s1">description)</span><span class="s0">;</span><span class="s1"> 
                weatherValues.put(WeatherContract.WeatherEntry.COLUMN_WEATHER_ID</span><span class="s0">, </span><span class="s1">weatherId)</span><span class="s0">;</span><span class="s1"> 
 
                cVVector.add(weatherValues)</span><span class="s0">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">int </span><span class="s1">inserted = </span><span class="s3">0</span><span class="s0">;</span><span class="s1"> 
            </span><span class="s2">// add to database</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">( cVVector.size() &gt; </span><span class="s3">0 </span><span class="s1">) { 
                ContentValues[] cvArray = </span><span class="s0">new </span><span class="s1">ContentValues[cVVector.size()]</span><span class="s0">;</span><span class="s1"> 
                cVVector.toArray(cvArray)</span><span class="s0">;</span><span class="s1"> 
                getContext().getContentResolver().bulkInsert(WeatherContract.WeatherEntry.CONTENT_URI</span><span class="s0">, </span><span class="s1">cvArray)</span><span class="s0">;</span><span class="s1"> 
 
                </span><span class="s2">// delete old data so we don't build up an endless history</span><span class="s1"> 
                getContext().getContentResolver().delete(WeatherContract.WeatherEntry.CONTENT_URI</span><span class="s0">,</span><span class="s1"> 
                        WeatherContract.WeatherEntry.COLUMN_DATE + </span><span class="s4">&quot; &lt;= ?&quot;</span><span class="s0">,</span><span class="s1"> 
                        </span><span class="s0">new </span><span class="s1">String[] {Long.toString(dayTime.setJulianDay(julianStartDay-</span><span class="s3">1</span><span class="s1">))})</span><span class="s0">;</span><span class="s1"> 
 
                notifyWeather()</span><span class="s0">;</span><span class="s1"> 
            } 
 
            Log.d(LOG_TAG</span><span class="s0">, </span><span class="s4">&quot;Sync Complete. &quot; </span><span class="s1">+ cVVector.size() + </span><span class="s4">&quot; Inserted&quot;</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
 
        } </span><span class="s0">catch </span><span class="s1">(JSONException e) { 
            Log.e(LOG_TAG</span><span class="s0">, </span><span class="s1">e.getMessage()</span><span class="s0">, </span><span class="s1">e)</span><span class="s0">;</span><span class="s1"> 
            e.printStackTrace()</span><span class="s0">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">private void </span><span class="s1">notifyWeather() { 
        Context context = getContext()</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s2">//checking the last update and notify if it' the first of the day</span><span class="s1"> 
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context)</span><span class="s0">;</span><span class="s1"> 
        String displayNotificationsKey = context.getString(R.string.pref_enable_notifications_key)</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">boolean </span><span class="s1">displayNotifications = prefs.getBoolean(displayNotificationsKey</span><span class="s0">,</span><span class="s1"> 
                Boolean.parseBoolean(context.getString(R.string.pref_enable_notifications_default)))</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s0">if </span><span class="s1">( displayNotifications ) { 
 
            String lastNotificationKey = context.getString(R.string.pref_last_notification)</span><span class="s0">;</span><span class="s1"> 
            </span><span class="s0">long </span><span class="s1">lastSync = prefs.getLong(lastNotificationKey</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
 
            </span><span class="s0">if </span><span class="s1">(System.currentTimeMillis() - lastSync &gt;= DAY_IN_MILLIS) { 
                </span><span class="s2">// Last sync was more than 1 day ago, let's send a notification with the weather.</span><span class="s1"> 
                String locationQuery = Utility.getPreferredLocation(context)</span><span class="s0">;</span><span class="s1"> 
 
                Uri weatherUri = WeatherContract.WeatherEntry.buildWeatherLocationWithDate(locationQuery</span><span class="s0">, </span><span class="s1">System.currentTimeMillis())</span><span class="s0">;</span><span class="s1"> 
 
                </span><span class="s2">// we'll query our contentProvider, as always</span><span class="s1"> 
                Cursor cursor = context.getContentResolver().query(weatherUri</span><span class="s0">, </span><span class="s1">NOTIFY_WEATHER_PROJECTION</span><span class="s0">, null, null, null</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
 
                </span><span class="s0">if </span><span class="s1">(cursor.moveToFirst()) { 
                    </span><span class="s0">int </span><span class="s1">weatherId = cursor.getInt(INDEX_WEATHER_ID)</span><span class="s0">;</span><span class="s1"> 
                    </span><span class="s0">double </span><span class="s1">high = cursor.getDouble(INDEX_MAX_TEMP)</span><span class="s0">;</span><span class="s1"> 
                    </span><span class="s0">double </span><span class="s1">low = cursor.getDouble(INDEX_MIN_TEMP)</span><span class="s0">;</span><span class="s1"> 
                    String desc = cursor.getString(INDEX_SHORT_DESC)</span><span class="s0">;</span><span class="s1"> 
 
                    </span><span class="s0">int </span><span class="s1">iconId = Utility.getIconResourceForWeatherCondition(weatherId)</span><span class="s0">;</span><span class="s1"> 
                    Resources resources = context.getResources()</span><span class="s0">;</span><span class="s1"> 
                    Bitmap largeIcon = BitmapFactory.decodeResource(resources</span><span class="s0">,</span><span class="s1"> 
                            Utility.getArtResourceForWeatherCondition(weatherId))</span><span class="s0">;</span><span class="s1"> 
                    String title = context.getString(R.string.app_name)</span><span class="s0">;</span><span class="s1"> 
 
                    </span><span class="s2">// Define the text of the forecast.</span><span class="s1"> 
                    String contentText = String.format(context.getString(R.string.format_notification)</span><span class="s0">,</span><span class="s1"> 
                            desc</span><span class="s0">,</span><span class="s1"> 
                            Utility.formatTemperature(context</span><span class="s0">, </span><span class="s1">high)</span><span class="s0">,</span><span class="s1"> 
                            Utility.formatTemperature(context</span><span class="s0">, </span><span class="s1">low))</span><span class="s0">;</span><span class="s1"> 
 
                    </span><span class="s2">// NotificationCompatBuilder is a very convenient way to build backward-compatible</span><span class="s1"> 
                    </span><span class="s2">// notifications.  Just throw in some data.</span><span class="s1"> 
                    NotificationCompat.Builder mBuilder = 
                            </span><span class="s0">new </span><span class="s1">NotificationCompat.Builder(getContext()) 
                                    .setColor(resources.getColor(R.color.colorAccent)) 
                                    .setSmallIcon(iconId) 
                                    .setLargeIcon(largeIcon) 
                                    .setContentTitle(title) 
                                    .setContentText(contentText)</span><span class="s0">;</span><span class="s1"> 
 
                    </span><span class="s2">// Make something interesting happen when the user clicks on the notification.</span><span class="s1"> 
                    </span><span class="s2">// In this case, opening the app is sufficient.</span><span class="s1"> 
                    Intent resultIntent = </span><span class="s0">new </span><span class="s1">Intent(context</span><span class="s0">, </span><span class="s1">Main.</span><span class="s0">class</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
 
                    </span><span class="s2">// The stack builder object will contain an artificial back stack for the</span><span class="s1"> 
                    </span><span class="s2">// started Activity.</span><span class="s1"> 
                    </span><span class="s2">// This ensures that navigating backward from the Activity leads out of</span><span class="s1"> 
                    </span><span class="s2">// your application to the Home screen.</span><span class="s1"> 
                    TaskStackBuilder stackBuilder = TaskStackBuilder.create(context)</span><span class="s0">;</span><span class="s1"> 
                    stackBuilder.addNextIntent(resultIntent)</span><span class="s0">;</span><span class="s1"> 
                    PendingIntent resultPendingIntent = 
                            stackBuilder.getPendingIntent( 
                                    </span><span class="s3">0</span><span class="s0">,</span><span class="s1"> 
                                    PendingIntent.FLAG_UPDATE_CURRENT 
                            )</span><span class="s0">;</span><span class="s1"> 
                    mBuilder.setContentIntent(resultPendingIntent)</span><span class="s0">;</span><span class="s1"> 
 
                    NotificationManager mNotificationManager = 
                            (NotificationManager) getContext().getSystemService(Context.NOTIFICATION_SERVICE)</span><span class="s0">;</span><span class="s1"> 
                    </span><span class="s2">// WEATHER_NOTIFICATION_ID allows you to update the notification later on.</span><span class="s1"> 
                    mNotificationManager.notify(WEATHER_NOTIFICATION_ID</span><span class="s0">, </span><span class="s1">mBuilder.build())</span><span class="s0">;</span><span class="s1"> 
 
                    </span><span class="s2">//refreshing last sync</span><span class="s1"> 
                    SharedPreferences.Editor editor = prefs.edit()</span><span class="s0">;</span><span class="s1"> 
                    editor.putLong(lastNotificationKey</span><span class="s0">, </span><span class="s1">System.currentTimeMillis())</span><span class="s0">;</span><span class="s1"> 
                    editor.commit()</span><span class="s0">;</span><span class="s1"> 
                } 
                cursor.close()</span><span class="s0">;</span><span class="s1"> 
            } 
        } 
    } 
 
    </span><span class="s5">/** 
     * Helper method to handle insertion of a new location in the weather database. 
     * 
     * </span><span class="s6">@param </span><span class="s5">locationSetting The location string used to request updates from the server. 
     * </span><span class="s6">@param </span><span class="s5">cityName A human-readable city name, e.g &quot;Mountain View&quot; 
     * </span><span class="s6">@param </span><span class="s5">lat the latitude of the city 
     * </span><span class="s6">@param </span><span class="s5">lon the longitude of the city 
     * </span><span class="s6">@return </span><span class="s5">the row ID of the added location. 
     */</span><span class="s1"> 
    </span><span class="s0">long </span><span class="s1">addLocation(String locationSetting</span><span class="s0">, </span><span class="s1">String cityName</span><span class="s0">, double </span><span class="s1">lat</span><span class="s0">, double </span><span class="s1">lon) { 
        </span><span class="s0">long </span><span class="s1">locationId</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s2">// First, check if the location with this city name exists in the db</span><span class="s1"> 
        Cursor locationCursor = getContext().getContentResolver().query( 
                WeatherContract.LocationEntry.CONTENT_URI</span><span class="s0">,</span><span class="s1"> 
                </span><span class="s0">new </span><span class="s1">String[]{WeatherContract.LocationEntry._ID}</span><span class="s0">,</span><span class="s1"> 
                WeatherContract.LocationEntry.COLUMN_LOCATION_SETTING + </span><span class="s4">&quot; = ?&quot;</span><span class="s0">,</span><span class="s1"> 
                </span><span class="s0">new </span><span class="s1">String[]{locationSetting}</span><span class="s0">,</span><span class="s1"> 
                </span><span class="s0">null</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s0">if </span><span class="s1">(locationCursor.moveToFirst()) { 
            </span><span class="s0">int </span><span class="s1">locationIdIndex = locationCursor.getColumnIndex(WeatherContract.LocationEntry._ID)</span><span class="s0">;</span><span class="s1"> 
            locationId = locationCursor.getLong(locationIdIndex)</span><span class="s0">;</span><span class="s1"> 
        } </span><span class="s0">else </span><span class="s1">{ 
            </span><span class="s2">// Now that the content provider is set up, inserting rows of data is pretty simple.</span><span class="s1"> 
            </span><span class="s2">// First create a ContentValues object to hold the data you want to insert.</span><span class="s1"> 
            ContentValues locationValues = </span><span class="s0">new </span><span class="s1">ContentValues()</span><span class="s0">;</span><span class="s1"> 
 
            </span><span class="s2">// Then add the data, along with the corresponding name of the data type,</span><span class="s1"> 
            </span><span class="s2">// so the content provider knows what kind of value is being inserted.</span><span class="s1"> 
            locationValues.put(WeatherContract.LocationEntry.COLUMN_CITY_NAME</span><span class="s0">, </span><span class="s1">cityName)</span><span class="s0">;</span><span class="s1"> 
            locationValues.put(WeatherContract.LocationEntry.COLUMN_LOCATION_SETTING</span><span class="s0">, </span><span class="s1">locationSetting)</span><span class="s0">;</span><span class="s1"> 
            locationValues.put(WeatherContract.LocationEntry.COLUMN_COORD_LAT</span><span class="s0">, </span><span class="s1">lat)</span><span class="s0">;</span><span class="s1"> 
            locationValues.put(WeatherContract.LocationEntry.COLUMN_COORD_LONG</span><span class="s0">, </span><span class="s1">lon)</span><span class="s0">;</span><span class="s1"> 
 
            </span><span class="s2">// Finally, insert location data into the database.</span><span class="s1"> 
            Uri insertedUri = getContext().getContentResolver().insert( 
                    WeatherContract.LocationEntry.CONTENT_URI</span><span class="s0">,</span><span class="s1"> 
                    locationValues 
            )</span><span class="s0">;</span><span class="s1"> 
 
            </span><span class="s2">// The resulting URI contains the ID for the row.  Extract the locationId from the Uri.</span><span class="s1"> 
            locationId = ContentUris.parseId(insertedUri)</span><span class="s0">;</span><span class="s1"> 
        } 
 
        locationCursor.close()</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s2">// Wait, that worked?  Yes!</span><span class="s1"> 
        </span><span class="s0">return </span><span class="s1">locationId</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s5">/** 
     * Helper method to schedule the sync adapter periodic execution 
     */</span><span class="s1"> 
    </span><span class="s0">public static void </span><span class="s1">configurePeriodicSync(Context context</span><span class="s0">, int </span><span class="s1">syncInterval</span><span class="s0">, int </span><span class="s1">flexTime) { 
        Account account = getSyncAccount(context)</span><span class="s0">;</span><span class="s1"> 
        String authority = context.getString(R.string.content_authority)</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) { 
            </span><span class="s2">// we can enable inexact timers in our periodic sync</span><span class="s1"> 
            SyncRequest request = </span><span class="s0">new </span><span class="s1">SyncRequest.Builder(). 
                    syncPeriodic(syncInterval</span><span class="s0">, </span><span class="s1">flexTime). 
                    setSyncAdapter(account</span><span class="s0">, </span><span class="s1">authority). 
                    setExtras(</span><span class="s0">new </span><span class="s1">Bundle()).build()</span><span class="s0">;</span><span class="s1"> 
            ContentResolver.requestSync(request)</span><span class="s0">;</span><span class="s1"> 
        } </span><span class="s0">else </span><span class="s1">{ 
            ContentResolver.addPeriodicSync(account</span><span class="s0">,</span><span class="s1"> 
                    authority</span><span class="s0">, new </span><span class="s1">Bundle()</span><span class="s0">, </span><span class="s1">syncInterval)</span><span class="s0">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s5">/** 
     * Helper method to have the sync adapter sync immediately 
     * </span><span class="s6">@param </span><span class="s5">context The context used to access the account service 
     */</span><span class="s1"> 
    </span><span class="s0">public static void </span><span class="s1">syncImmediately(Context context) { 
        Bundle bundle = </span><span class="s0">new </span><span class="s1">Bundle()</span><span class="s0">;</span><span class="s1"> 
        bundle.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
        bundle.putBoolean(ContentResolver.SYNC_EXTRAS_MANUAL</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
        ContentResolver.requestSync(getSyncAccount(context)</span><span class="s0">,</span><span class="s1"> 
                context.getString(R.string.content_authority)</span><span class="s0">, </span><span class="s1">bundle)</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s5">/** 
     * Helper method to get the fake account to be used with SyncAdapter, or make a new one 
     * if the fake account doesn't exist yet.  If we make a new account, we call the 
     * onAccountCreated method so we can initialize things. 
     * 
     * </span><span class="s6">@param </span><span class="s5">context The context used to access the account service 
     * </span><span class="s6">@return </span><span class="s5">a fake account. 
     */</span><span class="s1"> 
    </span><span class="s0">public static </span><span class="s1">Account getSyncAccount(Context context) { 
        </span><span class="s2">// Get an instance of the Android account manager</span><span class="s1"> 
        AccountManager accountManager = 
                (AccountManager) context.getSystemService(Context.ACCOUNT_SERVICE)</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s2">// Create the account type and default account</span><span class="s1"> 
        Account newAccount = </span><span class="s0">new </span><span class="s1">Account( 
                context.getString(R.string.app_name)</span><span class="s0">, </span><span class="s1">context.getString(R.string.sync_account_type))</span><span class="s0">;</span><span class="s1"> 
 
</span><span class="s2">//        // If the password doesn't exist, the account doesn't exist</span><span class="s1"> 
</span><span class="s2">//        if ( null == accountManager.getPassword(newAccount) ) {</span><span class="s1"> 
</span><span class="s2">//</span><span class="s1"> 
</span><span class="s2">//        /*</span><span class="s1"> 
</span><span class="s2">//         * Add the account and account type, no password or user data</span><span class="s1"> 
</span><span class="s2">//         * If successful, return the Account object, otherwise report an error.</span><span class="s1"> 
</span><span class="s2">//         */</span><span class="s1"> 
</span><span class="s2">//            if (!accountManager.addAccountExplicitly(newAccount, &quot;&quot;, null)) {</span><span class="s1"> 
</span><span class="s2">//                return null;</span><span class="s1"> 
</span><span class="s2">//            }</span><span class="s1"> 
</span><span class="s2">//            /*</span><span class="s1"> 
</span><span class="s2">//             * If you don't set android:syncable=&quot;true&quot; in</span><span class="s1"> 
</span><span class="s2">//             * in your &lt;provider&gt; element in the manifest,</span><span class="s1"> 
</span><span class="s2">//             * then call ContentResolver.setIsSyncable(account, AUTHORITY, 1)</span><span class="s1"> 
</span><span class="s2">//             * here.</span><span class="s1"> 
</span><span class="s2">//             */</span><span class="s1"> 
</span><span class="s2">//</span><span class="s1"> 
</span><span class="s2">//            onAccountCreated(newAccount, context);</span><span class="s1"> 
</span><span class="s2">//        }</span><span class="s1"> 
        </span><span class="s0">return </span><span class="s1">newAccount</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">private static void </span><span class="s1">onAccountCreated(Account newAccount</span><span class="s0">, </span><span class="s1">Context context) { 
        </span><span class="s2">/* 
         * Since we've created an account 
         */</span><span class="s1"> 
        DomotikSyncAdapter.configurePeriodicSync(context</span><span class="s0">, </span><span class="s1">SYNC_INTERVAL</span><span class="s0">, </span><span class="s1">SYNC_FLEXTIME)</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s2">/* 
         * Without calling setSyncAutomatically, our periodic sync will not be enabled. 
         */</span><span class="s1"> 
        ContentResolver.setSyncAutomatically(newAccount</span><span class="s0">, </span><span class="s1">context.getString(R.string.content_authority)</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s2">/* 
         * Finally, let's do a sync to get things started 
         */</span><span class="s1"> 
        syncImmediately(context)</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">public static void </span><span class="s1">initializeSyncAdapter(Context context) { 
        getSyncAccount(context)</span><span class="s0">;</span><span class="s1"> 
    } 
} 
</span></pre>
</body>
</html>